% !TeX root = ./main.tex

\section{バグ検出を考える上でのJulia言語の考察と先行研究}

% TODO: もっといい感じの枕詞
このセクションではまずJuliaの重要な性質を概観し，その静的解析に求められる要件を確認する．
その後，他の動的言語における静的解析によるエラーチェックの取り組みを紹介し，本論文において取りうるアプローチを検討する．

\subsection{Julia言語の特徴と静的解析}

% \subsubsection{generic function}
% why : 演算子の振る舞いが複雑，かつそれぞれの使用はパフォーマントでなくてはならない
% good: generic function に対する code specialization と code selection により dynamic duck typing の柔軟な多相性を保ったまま，パフォーマンスを得ることができる
%  bad: 実行時の呼び出し引数型により挙動や返りが型が決定するため，素のプログラム中のfunction signatureでは解析ができない

\subsubsection{generic function}

Juliaはgeneric function（総称関数）に対するcode specializationとcode selectionにより，動的な多相性を保ちつつ，良好なパフォーマンスを得ている．

% code specialization
ここで，generic functionは同一の名前を持ち多相的な振る舞いをする関数であり，generic functionは実行時にある引数を伴ってはじめて呼ばれたタイミングでコンパイル（これをJITコンパイル，または単にJITとよぶ）される．
JITの過程においては，まず引数の型情報を用いてその関数呼び出しに対する型推論が行われ，その関数内部で呼び出す関数（正確にはメソッド）の決定や，constant propagation, function inlingなどの標準的な最適化が行われた後，LLVMフレームワーク\cite{LLVM}を用いた最適化が行われ，最終的に個々のプラットフォームに対応したマシンコードが生成され，実行される．生成されたコードはキャッシュされ，次回以降の同じ引数型組を伴う呼び出しで使用される．
このgeneric functionのそれぞれの引数型組を伴う呼び出しに対する最適化のプロセスをcode specializationと呼ぶ．
例えば，Juliaに標準で備わっている\texttt{sum}関数の呼び出し\texttt{sum([1, 0, 1])}は\texttt{Array\{Int,1\}}という引数型に対し最適化されたマシンコードを生成し，引数型\texttt{Array\{Float64,1\}}を伴う呼び出し\texttt{sum([1., 0., 1.])}はまた別のコードを生成する．

% code selection
また，１つのgeneric functionは複数の実装を持つことができ，プログラマはgeneric functionの定義時に引数に型アノテーションを付けることで，その実装が適用され得る引数型組の集合を記述し，その引数に対し適切な実装（これをメソッドと呼ぶ）を与えることができる．
generic functionが呼ばれた時，そのメソッドの中から（全ての引数の実行時の型を考慮した上で）その引数型組に対し最も「特化した」もの
\footnote{
  「特化した」メソッドの定義が実は曖昧であることに触れておく．
}
が選択され実行される．
このdynamic multiple dispatchによるメソッドの選択をcode selectionと呼ぶ．

\newpage

具体例として，\texttt{sum}関数に対するcode selectionを考えてみる．Julia v1.5においては\texttt{sum}関数には標準ライブラリを含めて１４個のメソッドが与えられている．そのうちの３つを抜粋する．

\begin{minted}[
  frame=lines,
  linenos
]{julia}
  sum(a) = sum(identity, a)
  sum(a::AbstractArray; dims=:) = _sum(a, dims)
  sum(a::AbstractArray{Bool}) = count(a)

  sum((1, 0, 1))           # => 2
  sum([1, 0, 1])           # => 2
  sum(BitArray([1, 0, 1])) # => 2
\end{minted}

１行目のメソッドが最もgenericな場合を扱う実装であり，２行目のメソッドがgenericな配列型に対する実装，そして３行目のメソッドがboolean型の要素を持つ配列に特化した実装となっている．
５行目の呼び出しは\texttt{(1, 0, 1)}の型\texttt{Tuple\{Int,Int,Int\}}に合うメソッドシグネチャが\texttt{sum(a)}の他に存在しないため，１行目のメソッドにdispatchされる．次に，６行目の呼び出しは一般的な配列型の引数に特化した２行目のメソッドにdispatchされる．最後に７行目の呼び出しは，特に\texttt{BitArray}型の配列の効率的なメモリレイアウトを利用する\texttt{count}関数を呼び出す３行目のメソッドにdispatchされる．

ここで注意するべきなのは，型アノテーションは基本的にメソッドのdispatchをコントロールする目的のため\textbf{だけ}に用いられるということである．
例えば，\texttt{sum(a::AbstractArray; dims=:)}は和を取る配列の次元を指定するキーワード引数\texttt{dims}を受け取るため，最もgenericな\texttt{sum(a)}とは異なるメソッドである必要があるが
\footnote{
  キーワード引数はdispatchにおいて考慮されない．
}，
\texttt{sum}を呼び出す次のような関数\texttt{add\_sum}を定義する場合，型アノテーションの有無に関わらず呼び出し時の引数型に応じたcode specializationが行われるため，型アノテーションを付けることはパフォーマンスの向上には繋がらず，むしろいたずらにこの関数が持ちうる多相性を損なってしまうことになる．
\footnote{
  また型アノテーションにより，JITコンパイルの速度面でのパフォーマンスが向上することもない．
}，
\mint{julia}|add_sum(a) = a .+ sum(a)|
この例からも分かるように，様々なユースケースにおいて効率的に動くgeneric functionを用意するために言語のコア機能やパッケージの開発において型アノテーションを行うことはあっても，エンドユーザがパフォーマンスを得るためにプログラムにアノテーションをしなくてはならない場面はほとんどない．
\footnote{
  型アノテーションがcode selection以外の目的で用いられる場面としては，プログラム中の型推論で型が決定されない部分に型アノテーションをつけることで，コンパイラがコードを最適化する上でのヒントを与えるというものがある．\cite{type-annotation}
  コンパイラはアノテーションされた型情報を使ってコード生成を行い，その実行時にはアノテーションされた型と実際の型が一致することを確かめるアサーションが行われる．
}

以上のような言語設計により，プログラマは演算子や関数の複雑な振る舞いをgeneric functionのメソッドとして自然にプログラミングすることができ
\footnote{
  \begin{quote}
    Mathematics is the art of giving the same name to different things.
  \end{quote}
  という，Jules-Henri Poincaréの有名な警句に表されるように，数学において同一の名前の演算子は使用される文脈により非常に複雑な振る舞いをみせる．
  Juliaのプログラミングパターンにおいては，その名前から「連想される」振る舞いを行う限り，様々な実装（メソッド）を同一のgeneric functionに追加するが，
  そのそれぞれ異なる実装を持つメソッドが引数の型に応じて動的に呼ばれることは，そうした数学の振る舞いに対応する．
}，
またその呼び出しは実行時の型に対して最適化されるため，科学計算の動的な性質に対応しつつかつ効率的に実行されるプログラムを書くことができる．

一方でこの強力なJuliaの多相性はduck typingにより暗黙的にもたらされるため，バグの温床にもなりうる．
というのも，Juliaのプログラミングパターンにおいては，良くも悪くもプログラマはgeneric functionがある種out-of-boxに動くことを想定してプログラミングをすることになるからである．
Juliaの言語実装の大部分は自身で記述されているため，言語のコア機能から各パッケージに至るまで様々なレイヤーのコードが多相的にプログラムされている．
このJuliaの洗練された多相性によりそれらのコードは多くの場合でプログラマの期待通りに動くものの，そうでない場合に発生するエラーをプログラマが事前に予想することは難しい．

\newpage

例えば，以下のようなコマンドライン引数（文字列型の配列型）を整数にパースし，それらの和を返す関数\texttt{parse\_sum}があるとする．

\begin{minted}[
  frame=lines,
  linenos
]{julia}
  function parse_sum(args)
    ints = []
    for arg in args
      push!(ints, parse(Int, arg))
    end
    return sum(ints)
  end

  parse_sum(ARGS)
\end{minted}

このプログラムは一見するとバグが含まれていないように見え，実際に\texttt{ARGS}の長さが１以上の時は正常に動作する．
しかし，\texttt{ints}の型が\texttt{Array\{Any,1\}}であるため，\texttt{ARGS}が空の配列である場合に，４行目の\texttt{sum(ints)}の内部で呼び出される\texttt{zero(T)}（\texttt{T}は\texttt{sum}の引数の要素型，この場合は\texttt{Any}）で\texttt{zero(Any)}というメソッドの未定義エラーが発生する．
この場合，\texttt{ints = Int[]}として\texttt{ints}の要素型まで指定して宣言しておくとエラーは避けられるものの，\texttt{sum}が引数の要素型に制限を設けず多相的に定義されている以上，プログラマがこうしたエラーを事前に予測することは簡単ではない．

さらに，こうしたエラーを実行時前に静的に検査することも容易ではない．
というのは，一般にJuliaのgeneric functionの挙動は，その呼び出し時に与えられた引数型に従って決定されるからである．
型アノテーションを付けることでメソッドの引数の型が静的に決定される場合，解析は容易になる．しかし，上述したようにJuliaの型アノテーションはあくまでメソッドのdispatchをコントロールするために補助的に用いられるものであり，プログラムに闇雲にアノテーションを付けることは，そのプログラムの多相性の損失にも繋がるため，静的な型検のためだけに型アノテーションを強制することはできない．

\subsubsection{メタプログラミング}

また，Juliaはその強力なメタプログラミングによっても特徴付けられる．
Juliaプログラムは全て値を返す式であるが，プログラマはパースタイムにその式自体を操作することができる．
\footnote{
  こうしたマクロベースのメタプログラミングの他，関数のコンパイル時に引数の型情報を用いて新たにコードを生成しそれを実行するstaged programmingも可能である．
  Juliaのstaged programmingは上述したgeneric functionのdispatchのメカニズムを利用した非常に自然な言語機能として提供されており，
  コードの生成する関数自身がその他のgeneric functionと同じように呼び出され，生成されたコードは通常の関数呼び出しと同じようにJITコンパイルによる最適化が行われた後，実行される．
}

% TODO
Profiler.jl or JuMP ?
エラープロファイリングの例にも使える意味では，Profiler.jlなどの一般的なマクロの方が良いかも．

このメタプログラミングの機能により，冗長なコードをより簡潔に記述できる他，汎用言語のシンタックスの中でドメイン特化的な記述方法を許容することができ，科学計算における複雑な記法を単一の言語の中で表現することができる\cite{jeff-phd}\cite{DunningHuchetteLubin2017}．



\subsection{先行研究}

% \inputminted[frame=lines,linenos,breaklines]{julia}{sample.jl}
