% !TeX root = ./main.tex

\section{バグ検出を考える上でのJulia言語の考察と先行研究}

% TODO: もっといい感じの枕詞
このセクションではまずJuliaの重要な性質を概観し，その静的解析に求められる要件を確認する．
その後，他の動的言語における静的解析によるエラーチェックの取り組みを紹介し，本論文において取りうるアプローチを検討する．

\subsection{Julia言語の特徴と静的解析}

% \subsubsection{generic function}
% why : 演算子の振る舞いが複雑，かつそれぞれの使用はパフォーマントでなくてはならない
% good: generic function に対する code specialization と code selection により dynamic duck typing の柔軟な多相性を保ったまま，パフォーマンスを得ることができる
%  bad: 実行時の呼び出し引数型により挙動や返りが型が決定するため，素のプログラム中のfunction signatureでは解析ができない

\subsubsection{generic function}

Juliaはgeneric function（総称関数）に対するcode specializationとcode selectionにより，動的な多相性を保ちつつ，良好なパフォーマンスを得ている．

% code specialization
ここで，generic functionは同一の名前を持ち多相的な振る舞いをする関数であり，generic functionは実行時にある引数を伴ってはじめて呼ばれたタイミングでコンパイル（これをJITコンパイル，または単にJITとよぶ）される．
JITの過程においては，まず引数の型情報を用いてその関数呼び出しに対する型推論が行われ，その関数内部で呼び出す関数（正確にはメソッド）の決定や，constant propagation, function inlingなどの標準的な最適化が行われた後，LLVMフレームワーク\cite{LLVM}を用いた最適化が行われ，最終的に個々のプラットフォームに対応したマシンコードが生成され，実行される．生成されたコードはキャッシュされ，次回以降の同じ引数型組を伴う呼び出しで使用される．
このgeneric functionのそれぞれの引数型組を伴う呼び出しに対する最適化のプロセスをcode specializationと呼ぶ．
例えば，Juliaに標準で備わっている\verb|sum|関数の呼び出し\verb|sum([1, 0, 1])|は\verb|Array{Int,1}|という引数型に対し最適化されたマシンコードを生成し，引数型\verb|Array{Float64,1}|を伴う呼び出し\verb|sum([1., 0., 1.])|はまた別のコードを生成する．

% code selection
また，1つのgeneric functionは複数の実装を持つことができ，プログラマはgeneric functionの定義時に引数に型アノテーションを付けることで，その実装が適用され得る引数型組の集合を記述し，その引数に対し適切な実装（これをメソッドと呼ぶ）を与えることができる．
generic functionが呼ばれた時，そのメソッドの中から（全ての引数の実行時の型を考慮した上で）その引数型組に対し最も「特化した」もの\footnotemark
が選択され実行される．
このdynamic multiple dispatchによるメソッドの選択をcode selectionと呼ぶ．

\footnotetext{
  % TODO: describe what "specialized"
  「特化した」（specialized）メソッドの定義が実は曖昧であることに触れておく．
}

具体例として，\verb|sum|関数に対するcode selectionを考えてみる．Julia v1.5においては\verb|sum|関数には標準ライブラリを含めて計14個のメソッドが与えられている．そのうちの3つを抜粋する（読みやすさのためやや改変している）．

\inputminted[frame=lines, linenos]{julia}{src/sums_method.jl}

1行目のメソッドが最もgenericな場合を扱う実装であり，2行目のメソッドがgenericな配列型に対する実装，そして3行目のメソッドがboolean型の要素を持つ配列に特化した実装となっている．
5行目の呼び出しは\verb|(1, 0, 1)|の型\verb|Tuple{Int,Int,Int}|に合うメソッドシグネチャが\verb|sum(a)|の他に存在しないため，1行目のメソッドにdispatchされる．次に，6行目の呼び出しは一般的な配列型の引数に特化した2行目のメソッドにdispatchされる．最後に7行目の呼び出しは，特に\verb|BitArray|型の配列の効率的なメモリレイアウトを利用する\verb|count|関数を呼び出す3行目のメソッドにdispatchされる．

ここで注意するべきなのは，型アノテーションは基本的にメソッドのdispatchをコントロールする目的のため\textbf{だけ}に用いられるということである．
例えば，\verb|sum(a::AbstractArray; dims=:)|は和を取る配列の次元を指定するキーワード引数\verb|dims|を受け取るため，最もgenericな\verb|sum(a)|とは異なるメソッドである必要があるが\footnotetext{
  キーワード引数はdispatchにおいて考慮されないため，位置引数の型に対するdispatchを用いる必要がある．
}，
\verb|sum|を呼び出す次のような関数\verb|add_sum|を定義する場合，型アノテーションの有無に関わらず呼び出し時の引数型に応じたcode specializationが行われるため，型アノテーションを付けることはパフォーマンスの向上には繋がらず，むしろいたずらにこの関数が持ちうる多相性を損なってしまうことになる．\footnote{
  また型アノテーションにより，JITコンパイルの速度面でのパフォーマンスが向上することもない．
}

\mint{julia}|add_sum(a) = a .+ sum(a)|

この例からも分かるように，様々なユースケースにおいて効率的に動くgeneric functionを用意するために言語のコア機能やパッケージの開発において型アノテーションを行うことはあっても，エンドユーザがパフォーマンスを得るためにプログラムにアノテーションをしなくてはならない場面はほとんどない．
\footnote{
  型アノテーションがcode selection以外の目的で用いられる場面としては，プログラム中の型推論で型が決定されない部分に型アノテーションをつけることで，コンパイラがコードを最適化する上でのヒントを与えるというものがある\cite{type-annotation}．
  コンパイラはアノテーションされた型情報を使ってコード生成を行い，実行時にはアノテーションされた型と実際の型が一致することを確かめるアサーションが行われる．
}

以上のような言語設計により，プログラマは演算子や関数の複雑な振る舞いをgeneric functionのメソッドとして自然にプログラミングすることができ\footnotemark，
またその呼び出しは実行時の型に対して最適化されるため，科学計算の動的な性質に対応しつつかつ効率的に実行されるプログラムを書くことができる．

\footnotetext{
  \begin{quote}
    Mathematics is the art of giving the same name to different things.
  \end{quote}
  という，Jules-Henri Poincaréの有名な警句に表されるように，数学において同一の名前の演算子は使用される文脈により多様かつ複雑な振る舞いをみせる．
  Juliaのプログラミングパターンにおいては，その名前から「連想される」振る舞いを行う限り様々な実装（メソッド）を同一のgeneric functionに追加するが，
  そのそれぞれのメソッドが実行時の引数の型に応じて動的に呼ばれることで，そうした数学の複雑な振る舞いを自然にプログラミングすることができる．
}

\vspace{1ex}

一方でJuliaのこうした強力な多相性はduck typingにより暗黙的にもたらされるため，バグの温床にもなりうる．
というのも，Juliaのプログラミングパターンにおいては，良くも悪くもプログラマはgeneric functionがある種out-of-boxに動くことを想定しつつプログラミングをすることになるからである．
Juliaの言語実装の大部分は自身で記述されているため，言語のコア機能から各パッケージに至るまで様々なレイヤーのコードが多相的にプログラムされている．
このJuliaの洗練された言語設計によりそれらのコードは多くの場合でプログラマの期待通りに動くものの，そうでない場合に発生するエラーをプログラマが事前に予想することは難しい．

例えば，以下のようなコマンドライン引数（文字列型の配列型）を整数にパースし，それらの和を返す関数\verb|parse_sum|があるとする．

\begin{listing}[ht]
  \inputminted[frame=lines]{julia}{src/parse_sum.jl}
  \caption{poorly typed code}
  \label{lst:target1}
\end{listing}

このプログラムは一見するとバグが含まれていないように見え，実際に\verb|ARGS|の長さが1以上の時は正常に動作する．
しかし，\verb|ints|の型が\verb|Array{Any,1}|であるため，\verb|ARGS|が空の配列である場合に，4行目の\verb|sum(ints)|の内部における関数呼び出し\verb|zero(T)|（\verb|T|は\verb|sum|の引数の要素型，この場合は\verb|Any|である）において， \verb|zero(::Type{Any})|という呼び出しのシグネチャがdispatchされ得るメソッドが存在しないことによるエラーが発生する．
この場合，\verb|zero|をオーバーロードし\verb|zero(::Type{Any})|に対応するメソッドを追加するか，2行目を \jlinline{ints = Int[]} として\verb|ints|の要素型まで指定して宣言することでエラーは避けられるものの，\verb|sum|が引数の要素型に制限を設けず多相的に定義されている以上，\verb|sum|がgenericな配列型に対して動作すると期待するプログラマがこうしたエラーを事前に予測することは簡単ではない．

また，こうしたエラーを実行時前に静的に検出することも容易ではない．
というのは，一般にJuliaのgeneric functionの挙動は，その呼び出し時に与えられた引数型に従って決定されるからである．
型アノテーションを付けることでメソッドの引数の型が静的に決定される場合，静的型付けの言語で用いられるような標準的な型解析を行うことができるが，上述したようにJuliaの型アノテーションはメソッドのdispatchをコントロールするためにあくまで補助的に用いられるものであり，プログラムに闇雲にアノテーションを付けることは，そのプログラムの多相性の損失にも繋がるため，静的な型解析のためだけに型アノテーションを強制することはできない．

\subsubsection{メタプログラミング}

また，Juliaはそのメタプログラミング機能によっても特徴付けられる．

メタプログラミングはJuliaプログラムのいたるところで用いられる．例えば，上述の\verb|sum(a::AbstractArray; dims = :)|メソッドも実際にはメタプログラミングを用いて，同様の構造を持つ他の関数とまとめて定義されている．
\footnote{
  \url{https://github.com/JuliaLang/julia/blob/a7cd97a293df20b0f05c5ad864556938d91dcdea/base/reducedim.jl\#L648-L659}より抜粋．
}

\inputminted[frame=lines, firstline=3, lastline=12, breaklines]{julia}{src/sums_def.jl}

こうした文字操作的なメタプログラミングは他の動的言語でもよく見られる機能であるが，
Juliaのメタプログラミング機能は，プログラマがマクロを通じてパースタイムにおいてあらゆるプログラムをデータ構造として扱い操作することができるという点で，\textbf{より}強力であり，いわゆる「Lispスタイル」のマクロを提供している．
上のプログラムにおける\verb|@inline|など\verb|@|から始まるコードがマクロに相当し，ここでは，\verb|@inline|マクロは関数定義の式を受け取り，最適化の過程においてその関数をinliningするように促す「ヒント」をJITコンパイラに与えるメタ情報を関数定義に追加する．
言語のコア機能に限らずJuliaのエコシステムにおいてもマクロは頻繁に用いられており，例えばJuliaの数理最適化分野におけるデファクトスタンダードなパッケージであるJuMP.jl\cite{DunningHuchetteLubin2017}は独自のマクロを効果的に定義し，以下のような明瞭で簡潔なモデリング記法を提供している．

\begin{listing}[ht]
  \inputminted[frame=lines, linenos, firstnumber=1, firstline=4, lastline=10]{julia}{src/jump.jl}
  \caption{code including macros}
  \label{lst:target2}
\end{listing}

このようにJuliaのプログラミングパターンにおいては，いたるところでメタプログラミングが使用され\footnotemark，冗長なコードをより簡潔に記述できる他，科学計算の各分野におけるドメイン特化的な記法を単一の汎用言語のシンタックスの中で表現することができる\cite{jeff-phd}．

\footnotetext{
  こうしたパースタイムにおけるマクロ展開によるシンタックスレベルのメタプログラミングの他，関数のコンパイル時に引数の型情報を用いて新たにコードを生成しそれを実行するstaged programmingも可能である．
  Juliaのstaged programmingは上述したgeneric functionのdispatchのメカニズムを用いた非常に自然な言語機能として提供されている．
  コードの生成する関数自身がその他のgeneric functionと同じように呼び出され，生成されたコードは通常の関数呼び出しと同じようにJITコンパイルによる最適化が行われた後，実行される．
}

その一方で，一般にコードを生成するコード，つまりマクロ（あるいはstaged programmmingにおけるcode generator）はそれ自体がバグを含みやすく，またメタプログラミングは適切でない場面で使用された場合，コードの可読性を著しく下げてしまうこともある．
しかしそれにも関わらず，メタプログラミングを含むコードを静的に解析することは難しい．
例えば，listing~\ref{lst:target2}の3行目の\verb|@variable|マクロの引数式 \jlinline{0 <= x <= 2} \textbf{だけ}を見ると，まだ定義されていない変数\verb|x|を参照しているため未定義エラーを起こしてしまうように解析され得るが，実際には，この引数式はそのまま評価されず，\verb|@variable|マクロの展開時に式のそれぞれの形式に対応してJuMP.jlの内部的なデータとして変数\verb|x|を定義するようなプログラムが生成されるため，エラーは生じず正常に動作する．
この例からも分かるようにJuliaプログラムの正確な解析のためにはマクロ展開後のコードに対する解析を行う必要があるが，マクロ展開のためには何らかのインタプリタが必要になり，静的解析の実装における1つの障壁になりうる．\footnotemark

% REVIEW: eval など実行時の値を用いるメタプログラミングは原理的に完全な静的解析ができない
% \verb|eval|など実行時の値を用いるため原理的に完全な静的解析が不可能なメタプログラミング機能が存在する

\footnotetext{
  マクロの存在が静的解析の実装を難しくする例として，\href{https://github.com/julia-vscode/StaticLint.jl}{StaticLint.jl}での事例がある．
  StaticLint.jlは主にエディタのLinting機能のバックエンドとして使用されることを想定したパッケージであり，現行のエコシステムにおいて最も正確にJuliaプログラムに含まれるシンタックスレベルのエラーを検出することができるが，パフォーマンス上の理由から完全なマクロ展開をサポートしていない\cite{staticlint-performance}．
  マクロ展開に必要なプログラム解釈のプロセスは，解析の複雑度を上げ，結果として編集中のプログラムをリアルタイムで（on-the-flyに）解析可能なパフォーマンスを保つことを困難にする（例えばユーザが既に定義してあるマクロの定義を変更した場合，正確な解析のためにはもう一度プログラム全体を解釈しなおす必要がある）．
  そのため，現状ではlisting~\ref{lst:target2}の\texttt{@variable}ようなシンタックス上の意味を大きく変えるマクロについては，JuMP.jlなどエコシステムにおける重要度の高いパッケージのマクロのみをそれぞれ個別にspecial caseすることで部分的に対応している:
  e.g. \url{https://github.com/julia-vscode/StaticLint.jl/pull/72}
}


\subsection{先行研究}

% TODO: もっと厳密に理解 & 正確な用語を用いる: 少なくとPPLまで

以上のような，プログラムの堅牢性よりも記述性を優先し，duck-typingにより強力で柔軟なアドホック多相性を得るという思想は，いくつかの動的型付け言語の核をなすパラダイムであり，そのトレードオフとして生じるプログラムの品質保証に伴う困難さについてはそれらの言語においても同様の問題意識が存在する．

そうした動的言語で書かれたプログラムに対する型レベルでの解析取り組みとしては，これまで大きく以下の2つのアプローチが取られてきた．

\begin{enumerate}
  \item プログラムに追加的な型シグネチャを与えることにより，型検査を行う方針
  \item 素のプログラムに対し抽象解釈を行い，型を「プロファイリング」する方針
\end{enumerate}

以下ではそれぞれのアプローチについて，適宜既存の具体的なプロジェクトについて言及しつつ，その方式におけるトレードオフや問題点を考える．

なお，ここではシンタックスレベルで得られる情報を用いて行う解析方式については触れない．本論文の取り組みとして，シンタックスレベルではなく型レベルの情報をもちいてバグ検出を試みる理由については\ref{type-profiler-design}で述べる．

\subsubsection{追加的な型シグネチャによる型検査}

この方式では，たとえ動的型付けの言語で記述されたプログラムであっても，定義が完了したクラスや関数においてはある種の静的なシグネチャが存在することを期待し，その型シグネチャをプログラマ自身に記述させることで，ライブラリの実装と使用（呼び出し）がそのシグネチャと矛盾していないか検査を行う\cite{ruby-progress-report}．
多相性は，部分型多相やパラメータ多相の他，duck-typingに相当するものとしてstructural typingが使用されるが\footnotemark，いずれの場合もプログラマが与えるシグネチャにより明示的に導入される．
\footnotetext{
  structural subtypingの表現方法として，mypyは\href{https://mypy.readthedocs.io/en/latest/protocols.html\#protocols-and-structural-subtyping}{"Protocol"}と呼ばれるある種のインターフェースを明示的に指定させるが，Steepはクラスシグネチャのメソッド集合の包含関係から部分型関係を判断する． % REVIEW: 合ってる？自動でやってくれるのか
}
静的に型が決定できない場合，動的型を表す特殊な型を導入し検査を続ける．以降その動的型に対する操作についての検査は行われないため型安全性は保障されない．型検査器は動的型が導入された場合通常何らかの警告を出すが，そのレベルについてはそれぞれのプロジェクトにより異なる．
型シグネチャの記述方法としては，プログラムの実行には関与しない形で追加的に与える方法\footnotemark の他，TypeScript~\cite{typescript}のように元の言語との前方互換性を保たない拡張言語において型に関する記述を言語の標準機能として行えるようにするというものがある．
\footnotetext{
  例えば，mypyはPython3の標準機能であるdocstringを用いてプログラム中にシグネチャを記述するが，Steepはプログラム本体とは別のファイルを用意しそこにシグネチャを記述する．
  どちらの場合も，型シグネチャはそれぞれの言語との前方互換性を保つ形で与えられるため，型検査システムを導入したプログラムは元の言語処理系でそのまま動かすことができる．
}
この検査方式を採用したプロジェクトとしては数多くのプロジェクトが存在し，mypy~\cite{mypy}（Python），Steep~\cite{steep}，TypeScript（JavaScript）など，既に産業ソフトウェアの場面で実際に広く運用されているものもある．

この方式を採用することのメリットは様々ある．ここではその中でも重要と思われるものを述べる．
\begin{itemize}
  \item おおよその安全な型システムを得ることができる．
  \item 型検査はクラスや関数を単位に行われるため，実用的なパフォーマンスを得やすい．具体例として，mypyプロジェクトはincremental checkingなど様々なエンジニアリングを経てDropbox社の400万行ものコードベースに対し数分で検査可能なパフォーマンスを得ている\cite{dropbox}．また同様の理由から編集中のコードに対して型検査をリアルタイムに行うことで，補完や推論された型情報のフィードバックなど，プログラマにとって有用な情報を引き出すことも可能である．
  \item 遠藤，松本宗太郎，上野，住井，松本行弘ら（2019）\cite{ruby-progress-report}が述べるように，型検査自体に用いられる型シグネチャはそのライブラリのある種のAPIとして機能しうる．
  \item 型アノテーションを元のプログラムのパフォーマンスの向上に用いることが可能な場合がある．具体例として，mypyの型検査器はPythonで書かれたコードを専用のコンパイラでコンパイルすることで，約4倍のパフォーマンスの向上を得ている．
\end{itemize}

一方で，この方式のデメリットは，型シグネチャを書かせることによるプログラマ負担という1点に絞られるだろう．
つまり，動的言語はそもそも（おおよそ）その動的機能がもたらす柔軟な挙動と簡潔な記述性を目指して設計されているにも関わらず，この方式においてはプログラマは静的な型付けを意識しつつ，型の記述にかかる手間を受け入れなくてはならず，また型の記述はプログラムを冗長にしその簡潔性を損ない得る．

\subsubsection{抽象解釈による型プロファイリング}
