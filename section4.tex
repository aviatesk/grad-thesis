% !TeX root = ./main.tex

\section{評価と今後の課題} \label{section:4}

このsectionではTypeProfiler.jlの性能を評価し，また現状で把握している課題点についても報告する．

\subsection{実験と比較} \label{subsection:experiments-and-comparison}

% TODO: PPLまでには絶対やる
現時点ではTypeProfiler.jlの性能の正確な評価までは行うことができていない．

% \begin{itemize}
%   \item これまでに紹介したコードに対するレポート
%   \item self profiling ?\\
%         \verb|Core|モジュールの型を，自前のそれと置き換える必要がある: 間に合わなさそう．
%   \item ruby-type-profilerとの比較
% \end{itemize}

\subsection{今後の課題} \label{subsection:issues}

% TODO: もっとimpl & evaluation 進めたらもっと見えてくるはず

\subsubsection{built-in functionの型遷移関数の再実装}

Juliaの型推論システムは，もともとエラー検出を目的に作られていないため，
推論がbuilt-in functionの呼び出しに到達したとき，
その呼び出しの引数型組が実行時エラーを起こし得るものであってもその情報を伝播させない場合がある．
つまり，エラーが起きるか起きないか判断できないような引数型が与えられた場合，
通常全ての実行時型を含む唯一の型である\verb|Any|を返す．

この挙動はJuliaの型推論がもっぱらパフォーマンスの向上を目的として行われていることを考えれば自然な挙動であるが，
一方でTypeProfiler.jlはエラーの検出を目的としているため，より保守的にエラーの可能性を報告する方が好ましい．

Juliaのbuilt-in functionの数は数少ないとは言え，それらは手作業で実装される必要がある．
まだプロファイリングが未実装のbuilt-in functionのサポートは必須の課題である．

\subsubsection{マクロ展開に対するエラー検出}

TypeProfiler.jlは，マクロを全て展開した後のプログラムに対して解析を行う．
つまり，マクロ展開そのものに対する解析は行わない．

Juliaのマクロ展開においてマクロの返り値となる式を計算する際，
通常の関数呼び出しと同様の計算を行うことができるため，
マクロ展開自体に対しても型プロファリングを行える方が望ましい\footnote{
  また，マクロ展開を抽象解釈したときに分かるのは，
  そのマクロの返り値となる\textit{プログラムの抽象値}である．
  展開されたプログラムの抽象値と，そのマクロが使用されるプログラム部分との整合性を調べることにより，
  マクロが展開されるコンテクストに関するエラーを解析することも可能であると思われる．
}．

しかし，Juliaのcode speicializationはマクロ呼び出しに対しては行われず，
従ってTypeProfiler.jlが利用する型推論ルーチン自体もマクロ展開に対しては利用できないため，
現在のTypeProfiler.jlの設計ではマクロ展開に対する解析を実装することはできなかった．

マクロ展開に対するプロファイリングをどのように実装するべきかの検討は今後の課題である．
