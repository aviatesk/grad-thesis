% !TeX root = ./main.tex

\section{型プロファイラの設計} \label{section:3}

この節では，
まず本論文の取り組みとして型プロファイリングによる解析手法を採用する理由を
前節の先行研究（\ref{subsection:prev-reseaches}）を踏まえて説明する．
次に，Juliaの型推論システムについて，そのアルゴリズムや停止性などに関する基本的な性質を説明する．
というのは，本論文で提案する型プロファイラの設計方針や性質は，
結局その抽象解釈のメインルーチンとなるJuliaの型推論システムにより決まるからである．
そして最後に型プロファイラの実装であるTypeProfiler.jlの設計とその性質を説明する．

\subsection{Why "type profiler" ?}

Juliaプログラムに対する静的な型エラー解析の手法として，
本論文で抽象解釈による型プロファイリングを採用した理由は次の3点である．

\begin{enumerate}
  \item Juliaの言語機能として実装されている型推論システムをそのまま利用することができる．\\
        Juliaの型推論は実用上のJITコンパイルに耐え得る正確性とスケーラビリティをすでに備えており，
        また今後も発展していくことが期待される．
        この型推論システムを利用することで，
        抽象解釈を用いた型プロファイリング（\ref{subsubsection:type-profiling}）において
        問題となりやすいスケーラビリティを保ちつつ，型プロファイラを比較的容易に実装できる．
　\item Julia言語のプログラミングパターンと，追加的な型アノテーションによる検査方式との
        相性が良くないと思われる．
  % REVIEW: これいる？
  \item 型プロファイラは，素のJuliaプログラムに対して解析を行うことができるため，
        気軽に導入を試すことができる．
        そのためまだ静的な型エラー解析が広く行われていない現行のエコシステムにおいても受け入れやすいと思われる．
        将来的なJuliaプログラムに対する静的な型エラー解析の必要性を考える上での，足がかりと捉えることもできる．
\end{enumerate}

% TODO: 未整理すぎる！
2点目に関しては，本論文執筆時点ではまだ理解が未整理であるが，
ここでは現状における理解を説明しておく．
先述したように，ソースプログラムに対する型アノテーションは既にJuliaの言語機能として存在し，
型アノテーションの導入自体は自然に行うことができる．
一方で，Juliaプログラムにおいて型アノテーションは
generic functionのdispatchをコントロールする上で非常に重要な意味を持っており，
code selectionのメカニズムにおいて型アノテーションはJuliaプログラムの多相性を大きく左右し\footnotemark
，プログラムの意味論に根本的な影響を与える．
そのため，intra-proceduralな解析が可能な程度に引数型を限定できるような形で
静的な型エラー検査を目的とした追加的な型アノテーションを与える場合，
Juliaプログラムが本来持ちうる多相性を保つのは難しく，
Juliaの言語機能を大きく損なってしまう可能性が高い．

\footnotetext{
  型アノテーションを付けないことは，\texttt{Any}型のアノテーションを施すことと同義である．
  関数の引数に型アノテーションを施さないことは最もgenericな場合に対応するメソッドを定義する
  ことを意味し，引数に型アノテーションを施すことは一般にそのメソッドの多相性を低下させる．
  このことから，プログラマは型アノテーションによりJuliaプログラムの多相性を調整していると
  考えることもできる．
}


\subsection{Juliaの型推論システム} \label{subsection:julia-type-inference}

Juliaの実行過程においては，
メソッド呼び出し時，与えられた引数組型に対するそのメソッドのcode specializationがまだ行われていない場合
（つまりそのメソッドの，その引数型組に対する最適化されたコードのキャッシュがまだ存在しない場合），
呼び出しの最適化を目的として型推論が行われ，型推論の結果に基づいて最適化が行われる
（\hyperref[subsubsection:eval-process]{Juliaの実行プロセス}参照）．

Juliaのプログラムの式や変数の型は，プログラムを型レベルで抽象解釈することで推論される．
Juliaの型推論に用いられている解析手法は元々，
\cite{abstract-interpretation, scheme-for-automatic-inference}で提唱されたものであり，
Bezansonらによる論文~\cite{jeff-phd, jeff-master, julia-2012}ではこの手法のことを指して，
\textbf{data-flow analysis}という用語を用いており，以降本論文においても使用する．

Juliaの型推論は，MLなどの静的型付け言語における型推論とは根本的に異なる．
静的型付け言語においては通常，
unificationベースの型推論\cite{milner}が用いられ，
コンパイル時におけるプログラムの正しさの証明の一環として
ソースレベルの型システムからでは自明に得られないプログラムの性質を発見するために推論が行われるのに対して，
Juliaの型推論は，もとよりcode specializationによるパフォーマンスの向上の一環として，
プログラムの性質を「できる限りの範囲で詳細に\cite{jeff-phd}」調べるために行われる．

data-flow analysisは以下のような性質を持つ．

\begin{enumerate}
  \item 推論が柔軟である．
        例えば，
        変数は（明示的なキャストをせずとも）プログラムの各時点において異なる型を持つことができ，
        また推論により型は必ずしも決定されなくてもよいなど，
        より動的型付けに即した性質を備えている．
  \item 型システムが表現可能な型の数が有限でない場合においても，
        wideningと呼ばれる手法を用いることでアルゴリズムの停止性を保つことができる．
        また，ヒューリスティックを用いて推論中の型をナイーブな実装よりも早くより抽象的な型へ遷移させることで，
        推論の収束を早めることができる．
  \item 型推論の実装と言語仕様とを切り離すことが可能である．
        % REVIEW: Juliaの型推論ルーチンを明示的に呼び出すようなコードの場合もこれで合ってる？
        例えばJuliaにおいては，推論のcorrectnessを保つ限り，
        型推論の結果によってJuliaプログラムの意味論が変わることはなく，
        ただそのパフォーマンスが変わるだけである.
        このことはつまり，
        型推論のルーチンを改善しようとするときに言語仕様の変更を気にする必要がないことを意味し，
        結果としてコンパイラの開発スピードを早めることができる．
\end{enumerate}

以下では，まずこのJuliaの型推論システムの基本的なアルゴリズムを説明する．
その次にヒューリスティックを導入することによりこのアルゴリズムの停止性が与えられることを説明し，
最後にJuliaの型推論ルーチンの推論結果のcorrectnessについて言及する．

\subsubsection{アルゴリズム}

\hyperref[subsubsection:eval-process]{Juliaの実行プロセス}で述べたように，
型推論はgeneric functionがある引数型組を伴って初めて呼ばれたときに引き起こされ，
Juliaプログラムを
\textbf{SSA形式（Static Single Assignment Form）}\cite{julia-ssa}
に変換したlowered formに対して行われる．
このSSA形式はsurface ASTとは異なり，木構造のデータ構造ではなく，
関数呼び出しや条件分岐など「ある1つのことを行う」\textbf{statement}の連なりである．
SSA形式においては，各変数は使用される前に必ず定義され，また一度しか代入されない\footnote{
  ここで，SSA形式中の「変数」は元のプログラム中の変数と一対一に対応しない．
  元のプログラム中における変数の再代入は，SSA形式においては新たな変数への代入として変換される．
}上，control flowはネストせず，分岐先と対応する
\href{https://en.wikipedia.org/wiki/Basic_block}{"basic block"}
へのgotoとして表現される．
こうした性質からSSA形式は，
定数伝播（constant propagation）やデッドコード削除（dead code elimination）等
といった最適化を行うための分析に適している．
以下，単に"statement"という場合，このSSA形式のstatementを意味する．

Juliaの型推論は，\cite{graph-free-data-flow-analysis}で提案されたgraph freeな最大不動点計算の
フレームワークを相互再帰関数も扱えるように拡張したアルゴリズムにより実装されている．
基本となるアイディアは，
それぞれのstatementの副作用を決定し，
その型情報を，そのstatementからcontrol flowにより到達可能な全てのstatementに伝播させ，
プログラムの各時点おける状態をトレースするというものである．

以下にその基本的なアルゴリズムを説明する\cite{jameson, julia-2012}．

Juliaの型推論は，
1つの関数呼び出し内におけるプロセス（local type inference）と，
複数の関数呼び出しにまたがって行われるプロセス（interprocedural type inference）
の2つに分けて説明することができる
\footnote{
  正確には，この2つとは別に，comprehension（内包表記）に対する推論のサブルーチンが
  ある種のspecial caseとして存在する\cite{jameson}．
}．

\paragraph{local type inference}

$W$を次に推論されるべきstatementの集合とする． % REVIEW: 元の説明通りprogram counterとするべき？

まず，推論が始まる前に，推論されるメソッド内の状態を以下のように初期化する．

\begin{itemize}
  \item メソッドのエントリポイントとなるstatementを$W$に追加する
  \item メソッドの引数それぞれの型は推論されている型をそのままセットする
  \item 全てのローカル変数を\textbf{\texttt{Bottom}}型\footnotemark にセットする
  \item メソッドの返り値型を\verb|Bottom|型\footnotemark[\value{footnote}] にセットする
\end{itemize}

% TODO: Bottom型に関する説明
\footnotetext{
  \texttt{Bottom}型に関する説明．
}

その後，推論は以下のプロセスを$W$が空になるまで繰り返す．

\begin{enumerate}
  \item $W$に残っているstatementを1つ取り出す（以下"currrent statement"と呼ぶ）
  \item current statementの副作用を決定する．
        例えば代入は変数の型を変化させる．
        もしcurrent statementが関数呼び出しである場合，
        その関数の返り値型を推論する（このサブルーチンについては後述する）．
        推論を再帰的に行うことにより，すべてのstatementの型を導出することができる
  \item current statementから到達可能な\textbf{全ての}statement
        （以下そのそれぞれを"next statement"と呼ぶ）
        を$W$に追加し，そのそれぞれに対しcurrent statementの型情報を伝播させる．
        このプロセスは2つのstatementの変数の型を\textbf{type merge}させることで行われる．
        無限ループを避けるため，
        current statementとのtype mergeによりnext statementに含まれるいずれかの変数の型が変化する場合にのみ，
        next statementは$W$に追加される．
        このtype mergeにおいて，アルゴリズムの収束を保証するため，
        widening~\ref{subsubsection:inference-termination-and-heuristic}
        と呼ばれる手法が用いられる．
\end{enumerate}

current statementが関数呼び出しである場合，以下のサブルーチンにより関数呼び出しの返り値型が推論される．

\begin{itemize}
  \item generic functionの呼び出しである場合，まず呼び出しの引数組型とマッチするメソッドを求める\footnotemark．
        マッチするメソッドは，
        呼び出し引数組型とメソッドシグネチャの型のtype intersection
        （greatest lower bound，または交差型）が\texttt{Bottom}型とはならないものとして求まる．
        マッチしたメソッドのそれぞれに対して以上と同様の型推論を行い，
        全ての推論結果をmergeすることで，そのgeneric functionの呼び出しの返り値型を求める．
  \item 呼び出される関数がgeneric functionでない場合，それはbuilt-in functionの呼び出し
        である．
        built-in functionの数は限られており，その返り値型はhard codeされた型遷移関数により計算される．
\end{itemize}

$T$をこのサブルーチンの型遷移関数とし，
$f$をgeneric function，
$t_{arg}$を推論された引数組型，$s$と$g$をそれぞれ$f$のメソッドの引数のシグネチャと実装とすると，
generic functionの呼び出しに対するサブルーチンは以下のように表される．

\[
  T(f,t_{arg}) = \bigsqcup_{(s,g) \in f}T(g,t_{arg} \sqcap s)
\]

ここで，$\sqcup$，$\sqcap$はそれぞれtype intersectionとtype mergeに対応する演算である．

\footnotetext{
  この時，引数それぞれの型は必ずしもconcrete typeではないことに注意
  （Juliaの型推論においては，wideningにより全ての型がconcrete typeとはならない）．
  そのため，マッチするメソッドは複数ある可能性がある．
}

\paragraph{interprocedural type inference}

さらに，再帰関数の呼び出しに対応するため，
以上のプロセスをgeneric functionの呼び出しにまたがってinterproceduralに管理する，
次のような手続きを考える必要がある．

推論の過程において，呼び出しが生じたgeneric functionとその引数型組の組み合わせを保持しておく．
同一の呼び出しが生じた場合，
それらの呼び出し間で生じる全ての関数呼び出しを相互再帰関数呼び出しとして記録し，
それらの返り値型がまだ完全に推論されていないことを示す\textit{incomplete}タグを付与する．
\textit{incomplete}タグが付与されている全ての関数の返り値型がfix-point（不動点）に至るまで，
この相互再帰関数呼び出しのサイクルに対して推論のプロセスを繰り返す\footnote{
  このinterprocedural type inferenceの実装は，
  特に相互再帰呼び出しのサイクルが複数存在する場合などにおいて，型推論のパフォーマンスを大きく変える．
  Juliaの型推論アルゴリズムにおいてそれが実際どのように実装され，いかに技術的な課題点が克服されているかについては
  \cite{jameson, jameson-revisited}が詳しいが，ここでは詳細な説明は避ける．
}．

\subsubsection{停止性とヒューリスティック} \label{subsubsection:inference-termination-and-heuristic}

上記のアルゴリズムを使用したdata-flow analysisは以下の性質を満たす場合に，
必ず収束し停止することが保証される\cite{graph-free-data-flow-analysis, jameson}．

\begin{description}
  \item [単調性] 2つの型をmergeしたときに必ずより抽象的な型にならなければならない．
                また，data-flow analysisにおける関数呼び出しは単調でなければならない．
                つまり引数型が抽象的であるほど，推論される返り値型も抽象的でなければならない．
  \item [有限性] 型システムにおいて表現され得る型が有限である．
\end{description}

有限性に関して，
Juliaの型システムは\verb|Union|型や\verb|Tuple|型，そしてコンテナ型の存在により，
無限の型が作られ得る（型システムは高さが有限でないlatticeとして表される）ので，
そのままではこの条件を満たさない．
そこで，\textbf{widening}と呼ばれる手法を用いて
型推論時におけるtype latticeの高さが有限となるように強制する．
この時，ヒューリスティックを用いて推論中の型をより早く抽象的な型に遷移させることで，
型推論自体の収束を早めている．

\subsubsection{correctness} \label{subsubsection:inference-correctness}

\cite{graph-free-data-flow-analysis}のアルゴリズムを用いたdata-flow analysisには，
推論された型について次の性質が成り立つ\cite{jeff-master}．

\begin{quote}
  Dynamic type inference schemes obey a correctness property that inferred types
  must subsume all possible run-time types.
\end{quote}


\subsection{TypeProfiler.jlの設計と性質}

この節では本論文で提案する型プロファイラの実装であるTypeProfiler.jlの設計と，その性質に関する説明を行う．

\subsubsection{設計}

% Juliaのinferenceとの違い:
% - もともとはperformance
% - inferenceがAnyが来たときにAnyを返す: inferenceの方で書く
% - それに対応する必要がある

% ruby-type-profilerとのルーチンの違い:
% - 言語設計から生じる違いがある？
%   * Ruby: 型はクラスになる <- コンテナ型はどうなる？
%   * Julia: 様々な型がある
% - 型システムの設計になる

実装は\url{https://github.com/aviatesk/TypeProfiler.jl}で公開している．

\subsubsection{性質}

% lemma:
% built-in callまで伝播したデータ型が，その呼び出しに対してvalidである場合，データ型エラーは起きない

% 型が決定できる場合がどの程度あるのか
% - 呼び出すコードが変わると

% どのエラーが検知できて，できないのか

% - precision vs. scalability
