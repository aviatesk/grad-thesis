% !TeX root = ./main.tex

\section{型プロファイラの設計方針} \label{section:3}

この節では，
まず本論文の取り組みとして型プロファイリングによる解析手法を採用する理由を
前節の先行研究（\ref{subsection:prev-reseaches}）を踏まえて説明する．
次に，Juliaの型推論システムについて，そのアルゴリズムや停止性などに関する基本的な性質を説明する．
というのは，本論文で提案する型プロファイラの設計方針や性質は，
結局その抽象解釈のメインルーチンとなるJuliaの型推論システムにより決まるからである．
そして最後にその型プロファイラの実装であるTypeProfiler.jlの設計を紹介する．

\subsection{Why "type profiler" ?}

Juliaプログラムに対する静的な型エラー解析の手法として，
本論文で抽象解釈による型プロファイリングを採用した理由は次の3点である．

\begin{enumerate}
  \item Juliaの言語機能として実装されている型推論システムを再利用することができる．\\
        Juliaの型推論は実用上のJITコンパイルに耐え得る正確性とスケーラビリティをすでに備えており，
        また今後も発展していくことが期待される．
        この型推論システムを再利用することで，
        抽象解釈を用いた型プロファイリング（\ref{subsubsection:type-profiling}）において
        問題となりやすいスケーラビリティを保ちつつ，型プロファイラを比較的容易に実装できる．
　\item Julia言語のプログラミングパターンと，追加的な型アノテーションによる検査方式との
        相性が良くないと思われる．
  % REVIEW: これいる？
  \item 型プロファイラは，素のJuliaプログラムに対して解析を行うことができるため，
        気軽に導入を試すことができる．
        そのためまだ静的な型エラー解析が広く行われていない現行のエコシステムにおいても受け入れやすいと思われる．
        将来的なJuliaプログラムに対する静的な型エラー解析の必要性を考える上での，足がかりと捉えることもできる．
\end{enumerate}

% TODO: 未整理すぎる！
2点目に関しては，本論文執筆時点ではまだ理解が未整理であるが，
ここでは現状における理解を説明しておく．
先述したように，ソースプログラムに対する型アノテーションは既にJuliaの言語機能として存在し，
型アノテーションの導入自体は自然に行うことができる．
一方で，Juliaプログラムにおいて型アノテーションは
generic functionのdispatchをコントロールする上で非常に重要な意味を持っており，
code selectionのメカニズムにおいて，型アノテーションはJuliaプログラムの多相性を大きく左右する\footnotemark ため，
静的な型エラー検査を目的とした追加的な型アノテーションはgeneric functionの多相性を損なわない形で導入される必要がある．
しかし，intra-proceduralな解析が可能な程度に引数型を静的に限定しつつ，
かつJuliaのgeneric functionが持つ多相性を損なわないような型システムを構築するのは簡単ではないと思われる．

\footnotetext{
  型アノテーションを付けないことは，\texttt{Any}型のアノテーションを施すことと同義である．
  関数の引数に型アノテーションを施さないことは最もgenericな場合に対応するメソッドを定義する
  ことを意味し，引数に型アノテーションを施すことは一般にそのメソッドの多相性を低下させる
  （Listing~\ref{lst:sums}参照）．
  このことから，プログラマは型アノテーションによりJuliaプログラムの多相性を調整していると
  考えることもできる．
}

\subsection{Juliaの型推論システム}

% - アルゴリズム
% - 停止性
% - 推論の正しさ -- runtime check いらないのか

\subsection{TypeProfiler.jlの設計}

% - precision vs. scalability
