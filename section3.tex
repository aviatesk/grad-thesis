% !TeX root = ./main.tex

\section{型プロファイラの設計方針} \label{section:3}

この節では，
まず本論文の取り組みとして型プロファイリングによる解析手法を採用する理由を
前節の先行研究（\ref{subsection:prev-reseaches}）を踏まえて説明する．
次に，Juliaの型推論システムについて，そのアルゴリズムや停止性などに関する基本的な性質を説明する．
というのは，本論文で提案する型プロファイラの設計方針や性質は，
結局その抽象解釈のメインルーチンとなるJuliaの型推論システムにより決まるからである．
そして最後に型プロファイラの実装であるTypeProfiler.jlの設計とその性質を説明する．

\subsection{Why "type profiler" ?}

Juliaプログラムに対する静的な型エラー解析の手法として，
本論文で抽象解釈による型プロファイリングを採用した理由は次の3点である．

\begin{enumerate}
  \item Juliaの言語機能として実装されている型推論システムを再利用することができる．\\
        Juliaの型推論は実用上のJITコンパイルに耐え得る正確性とスケーラビリティをすでに備えており，
        また今後も発展していくことが期待される．
        この型推論システムを再利用することで，
        抽象解釈を用いた型プロファイリング（\ref{subsubsection:type-profiling}）において
        問題となりやすいスケーラビリティを保ちつつ，型プロファイラを比較的容易に実装できる．
　\item Julia言語のプログラミングパターンと，追加的な型アノテーションによる検査方式との
        相性が良くないと思われる．
  % REVIEW: これいる？
  \item 型プロファイラは，素のJuliaプログラムに対して解析を行うことができるため，
        気軽に導入を試すことができる．
        そのためまだ静的な型エラー解析が広く行われていない現行のエコシステムにおいても受け入れやすいと思われる．
        将来的なJuliaプログラムに対する静的な型エラー解析の必要性を考える上での，足がかりと捉えることもできる．
\end{enumerate}

% TODO: 未整理すぎる！
2点目に関しては，本論文執筆時点ではまだ理解が未整理であるが，
ここでは現状における理解を説明しておく．
先述したように，ソースプログラムに対する型アノテーションは既にJuliaの言語機能として存在し，
型アノテーションの導入自体は自然に行うことができる．
一方で，Juliaプログラムにおいて型アノテーションは
generic functionのdispatchをコントロールする上で非常に重要な意味を持っており，
code selectionのメカニズムにおいて型アノテーションはJuliaプログラムの多相性を大きく左右し\footnotemark
，プログラムの意味論に根本的な影響を与える．
そのため，intra-proceduralな解析が可能な程度に引数型を限定できるような形で
静的な型エラー検査を目的とした追加的な型アノテーションを与える場合，
Juliaプログラムが本来持ちうる多相性を保つのは難しく，
Juliaの言語機能を大きく損なってしまう可能性が高い．

\footnotetext{
  型アノテーションを付けないことは，\texttt{Any}型のアノテーションを施すことと同義である．
  関数の引数に型アノテーションを施さないことは最もgenericな場合に対応するメソッドを定義する
  ことを意味し，引数に型アノテーションを施すことは一般にそのメソッドの多相性を低下させる．
  このことから，プログラマは型アノテーションによりJuliaプログラムの多相性を調整していると
  考えることもできる．
}


\subsection{Juliaの型推論システム} \label{subsection:julia-type-inference}

Juliaの実行過程においては，
メソッド呼び出し時，与えられた引数組型に対するそのメソッドのcode specializationがまだ行われていない場合
（つまりそのメソッドの，その引数型組に対する最適化されたコードのキャッシュがまだ存在しない場合），
呼び出しの最適化を目的として型推論が行われ，型推論の結果に基づいて最適化が行われる
（\hyperref[subsubsection:eval-process]{Juliaの実行プロセス}参照）．

Juliaのプログラムの式や変数の型は，プログラムを型レベルで抽象解釈することで推論される．
Juliaの型推論に用いられている解析手法は元々，
\cite{abstract-interpretation, scheme-for-automatic-inference}で提唱されたものであり，
Bezansonらによる論文~\cite{jeff-phd, jeff-master, julia-2012}ではこの手法のことを指して，
\textbf{data-flow analysis}という用語を用いており，以降本論文においても使用する．

Juliaの型推論は，MLなどの静的型付け言語における型推論とは根本的に異なる．
静的型付け言語においては通常，
unificationベースの型推論\cite{milner}が用いられ，
コンパイル時におけるプログラムの正しさの証明の一環として
ソースレベルの型システムからでは自明に得られないプログラムの性質を発見するために推論が行われるのに対して，
Juliaの型推論は，もとよりcode specializationによるパフォーマンスの向上の一環として，
プログラムの性質を「できる限りの範囲で詳細に\cite{jeff-phd}」調べるために行われる．

data-flow analysisは以下のような性質を持つ．

\begin{enumerate}
  \item 推論が柔軟である．
        例えば，変数はプログラムの各時点において異なる型を持つことができ，
        また推論により型は必ずしも決定されなくてもよいなど，
        より動的型付けに適した性質を備えている．
  \item 型システムが表現可能な型の数が有限でない場合においても，
        wideningと呼ばれる手法を用いることでアルゴリズムの停止性を保つことができる．
        また，ヒューリスティックを用いて推論中の型をナイーブな実装よりも早くより抽象的な型へ遷移させることで，
        推論の収束を早めることができる．
  \item 型推論の実装と言語仕様とを切り離すことが可能である．
        % REVIEW: Juliaの型推論ルーチンを明示的に呼び出すようなコードの場合もこれで合ってる？
        例えばJuliaにおいては，推論のcorrectnessを保つ限り，
        型推論の結果によってJuliaプログラムの意味論が変わることはなく，
        ただそのパフォーマンスが変わるだけである.
        このことはつまり，
        型推論のルーチンを改善しようとするときに言語仕様の変更を気にする必要がないことを意味し，
        結果としてコンパイラの開発スピードを早めることができる．
\end{enumerate}

以下では，まずこのJuliaの型推論システムの基本的なアルゴリズムを説明する．
その次にヒューリスティックを導入することによりこのアルゴリズムの停止性が与えられることを説明し，
最後にJuliaの型推論ルーチンの推論結果のcorrectnessについて言及する．

\subsubsection{アルゴリズム}

Juliaの型推論は，\cite{graph-free-data-flow-analysis}で提案されたgraph freeな最大不動点計算の
フレームワークを相互再帰関数も扱えるように拡張したアルゴリズムにより実装されている．

\subsubsection{停止性とヒューリスティック} \label{subsubsection:inference-termination-and-heuristic}

上記のアルゴリズムを使用したdata-flow analysisは以下の性質を満たす場合に，
必ず収束し停止することが保証される\cite{graph-free-data-flow-analysis, jameson}．

\begin{description}
  \item [単調性] 2つの型をmergeしたときに必ずより抽象的な型にならなければならない．
                また，data-flow analysisにおける関数呼び出しは単調でなければならない．
                つまり引数型が抽象的であるほど，推論される返り値型も抽象的でなければならない．
  \item [有限性] 型システムにおいて表現され得る型が有限である．
\end{description}

有限性に関して，
Juliaの型システムは\verb|Union|型や\verb|Tuple|型，そしてコンテナ型の存在により，
無限の型が作られ得る（型システムは高さが有限でないlatticeとして表される）ので，
そのままではこの条件を満たさない．
そこで，\textbf{widening}と呼ばれる手法を用いて
型推論時におけるtype latticeの高さが有限となるように強制する．
この時，ヒューリスティックを用いて推論中の型をより早く抽象的な型に遷移させることで，
型推論自体の収束を早めている．

\subsubsection{correctness} \label{subsubsection:inference-correctness}

\cite{graph-free-data-flow-analysis}のアルゴリズムを用いたdata-flow analysisには，
推論された型について次の性質が成り立つ\cite{jeff-master}．

\begin{quote}
  Dynamic type inference schemes obey a correctness property that inferred types
  must subsume all possible run-time types.
\end{quote}


\subsection{TypeProfiler.jlの設計と性質}

この節では本論文で提案する型プロファイラの実装であるTypeProfiler.jlの設計と，その性質に関する説明を行う．

\subsubsection{設計}

% Juliaのinferenceとの違い:
% - もともとはperformance
% - inferenceがAnyが来たときにAnyを返す: inferenceの方で書く
% - それに対応する必要がある

% ruby-type-profilerとのルーチンの違い:
% - 言語設計から生じる違いがある？
%   * Ruby: 型はクラスになる <- コンテナ型はどうなる？
%   * Julia: 様々な型がある
% - 型システムの設計になる

実装は\url{https://github.com/aviatesk/TypeProfiler.jl}で公開している．

\subsubsection{性質}

% lemma:
% built-in callまで伝播したデータ型が，その呼び出しに対してvalidである場合，データ型エラーは起きない

% 型が決定できる場合がどの程度あるのか
% - 呼び出すコードが変わると

% どのエラーが検知できて，できないのか

% - precision vs. scalability
